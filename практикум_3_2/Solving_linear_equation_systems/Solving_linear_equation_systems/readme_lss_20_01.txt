Кобиков Яромир, М1-16, филиал МГУ им. М.В.Ломоносова.

Раздел: Решение систем линейных уравнений.
	Задача: № 1.
		Условие: Метод Гаусса с выбором главного элемента по строке.


Параметры алгоритма и интерфейсные параметры передаваются через параметры командной строки. Образец синтаксиса:

/home/ivk/lss/lss
Usage: lss [input_file_name] [output_file_name] [options]
Where options include:
  -d    print debug messages [default OFF]
  -e    print errors [default OFF]
  -p    print matrix [default OFF]
  -t    print execution time [default OFF]
  -h, -?     print this and exit
Default input_file_name value is lss_20_01_in.txt, default output_file_name value is lss_20_01_out.txt.

Здесь первая строчка - расположение бинарника программы (первое строковое поле аргументов функции main). Пример вызова программы:

./lss input.txt output.txt -e -t


Формат входного файла:

   n
   a_1_1 a_1_2 ... a_1_n
   a_2_1 a_2_2 ... a_2_n
   .....................
   a_n_1 a_n_2 ... a_n_n
   b_1
   b_2
   ...
   b_n

Здесь n - число уравнений в системе (число неизвестных всегда считаем равным числу уравнений), a_i_j - элементы матрицы системы, b_i - элементы вектора правой части.

Формат чисел: n - "%d", a_i_j и b_i - "%lf".

Формат выходного файла. Если решение существует (для переопределенных систем свободные неизвестные полагать нулями)

   n
   x_1
   x_2
   ...
   x_n

Если решения не существует, выходной файл должен содержать одну единственную цифру '0'.

Формат чисел: n - "%d", x_i - "%1.9lf".


Методы в файле main_lss_20_01.с:

	size_t lss_memsize_20_01(int n) - определяется размер массива дополнительной памяти. Возвращаемое значение - int - n * sizeof(double).

	int check_str(char * first, char * last) - валидация интерфейсных параметров. Aргументы: 1 - что сравнить, 2 - с чем сравнить. Проверяемый элемент сравнивается по первым двум символам со значениями из ['-h', '-d','-e','-p','-t','-h', '-?']. Валидацию first не проходит, если нет подходящего из доступных параметров или длина first (> 2 || < 2). Возвращаемое значение в случае успеха 0, неудача 1.

	int check_name_txt(char * first) - проверка на присутствие интерфейсных параметров на "расширения - '.txt' ", для файлов. Aргумент - указатель на строка(тип char *). Если первый символ != '-', метод пробегает по строке входного аргумента, то ищет последовательность '.txt'. Возвращаемое значение в случае успеха 0, неудача 1.

	int errors(int code) - фильтр-вывод ошибки. Аргумент - код ошибки (тип int). Если глобальная переменная var_for_errors == 1, то при фильтрации кода, на экран пользователя будет выводиться соответсвующее передупреждение. Возвращаемое значение код ошибки.

	print_matrix(int n, double *  A, double * B) - печать матрицы A и B. Аргументы: размерность матрицы(для A, будет n*n), матрица A, матрица B.

	int main(int argc, char *argv[]) - главная функция. Аргументы входные значения командной строки. Первым этапом проверяются входные аргументы, если они есть. Выделение памяти под массив значений матрицы A, B, X, tmp. массив tmp заполняется числами от 1.0 до n(описание ниже в алгоритме решения).  Затем считывание данных из входного файла. Печать матриц A и B, если глобальный флаг var_for_debug == 1 или было введено с консоли "-p" (print matrix) 

Методы в файле lss_20_01.с:

	void print_matrix_a_b(int n, double * A, double * B, char * string) - печать заголовка и матрицы А и В. Агрументы: размерность матрицы(для A, будет n*n), матрица A, матрица B, строка для заголовка.

	int lss_20_01(int n, double * A, double * B, double * X, double * tmp) - Здесь A - массив с матрицей системы в формате a_1_1 a_1_2 ... a_1_n a_2_1 a_2_2 ... a_n_n для матрицы общего вида, B - массив правых частей, X - массив решения, tmp - массив дополнительной памяти( Методу Гаусса с выбором главного элемента по строке, требуется дополнительный массив для хранения индексов переменных). Возвращаемое значеные: 0 - работа завершена успешно, решение построено / 1 - работа завершена успешно, решения системы не существует.


Алгоритм решения задачи:
	Алгоритм состоит из двух шагов - прямой ход и обратный.
		Прямой:
			Исходная система: a11*x1+a12*x2+...+a1n*xn=b1
							  a21*x1+a22*x2+...+a2n*xn=b2
							  ...........................
							  an1*x1+an2*x2+...+ann*xn=bn
			Исходная система сводится к эквивалентной системе с верхней треугольной матрицей вида:
							  	  x1+a12*x2+...+a1n*xn=b1
							  			 x2+...+a1n*xn=b1
							  			 	   ..........
							  			 			xn=bn
			1 шаг. 
				Выбор главного элемента по строке. Находим максимальный элемент i-ой строки. Eсли aii < aij то элементы столбца i меняем местами со столбцом j.
				При перестановке столбцов меняется порядок неизвестных, поэтому в этом случае надо запомнить новый порядок неизвестных. Для этого используем вспомогательный массив с элементами, соответствующими порядку неизвестных. Изначально он заполнен индексами неизвестных от 1.0 до n. По мере перестановки столбцов элементы этого массива с индексами тоже будет поменяться(в зависимости от i и j столбцов). Прио братном ходе вместо индекса массива неизвестных будем использовать элемент этого массива. При нахождении максимального элемента проверяем чтобы все элементы строки не были равны 0, так как в случае, если правая часть матрицы B будет не равна 0, а соответсвующая строка матрицы A будет = 0, то решения не будет и выводится код ошибка = 1.
			2 шаг.
				i-ю строку матрицы A и B делим на элемент save_1 = aii матрицы A. Зануляем первый столбец без первой строки.
				Изменяем матрицу по формулам: 
				save_1 = aii; (сохраняем элемент матрицы aii)
				bi = bi / save_1; (делим i-ый элемент матрицы B на aii)
				aij = aij / save_1 (save_1 != 0, j = 0,..., n); (делим i-ую строку матрицы А на aii)
				Преобразовываем остальную часть матрицы:
					save_1 = aji; (сохраняем первый(нулевой) элемент следующей строки матрицы)
					ajk = ajk − save_1 * aik (j = i + 1,..., n; k = i,...,n);
				В результате получим верхнюю треугольную матрицу.
		Обратный:
			Учитывая изменения порядка индексов дополнительного массива, вычисляем -  xi = bi, xi = xi - aij * xj (i = n - 1,..., 0; j = n - 1,..., i);

Коды ошибок:

	404 (ERROR_OPEN_FILE_IN) - ошибка открытия файла для считывания данных. Возможно не правильно указано имя файла.
	406 (ERROR_OPEN_FILE_OUT) - ошибка открытия файла для записи ответа. Возможно не правильно указано имя файла.

	68 (ERROR_DIMENSION) - ошибка значения(первая строка входного файла для считывания) числа уравнений в файле (число неизвестных всегда считаем равным числу уравнений и оно не должно быть "< 2").

	66 (ERROR_DIMENSION_MATRIX_A) - ошибка размерности матрицы A. Возникает, если значений матрицы B нет, а в матрице А не хватает элементов(при считывании с файла). Матрица A размерности n на n (где n - значение указываемое в первом поле входного файла).

	68 (ERROR_DIMENSION_MATRIX_B) - ошибка размерности матрицы B. Возникает, если не хватает значений для матрицы правых частей уравнений.(размерность матрицы B = n)

	400 (ERROR_INPUT) - ошибка ввода аргументов. Возможные причины: если расширение указанных файлов (входного, выходного) не соответсвует - ".txt", если введеные опции не верны или их не существет.

	200 (PRINT_INFO) - код запроса списка опций.
	500 (ERROR_EMPTY) - ошибка чтения входного файла (файл пустой или присутвует строка типа не int).





	


