Кобиков Яромир, М1-16, филиал МГУ им. М.В.Ломоносова.

Раздел: Поиск собственных значений матриц.
  		Задача: № 1.
    	    Условие: LR с отражениями.

Параметры алгоритма и интерфейсные параметры передаются через параметры командной строки. Образец синтаксиса:

/home/ivk/evc$ ./evc -?
Usage: evc [input_file_name] [output_file_name] [options]
Where options include:
 -d                print debug messages [default OFF]
 -e                print errors [default OFF]
 -p                print matrix [default OFF]
 -t                print execution time [default OFF]
 -prec=<num>       precision [default - 1e-14]
 -eps=<num>        epsilon [default - 1e-10]
 -max_iter=<num>   limit number of iterations [default - 0, i.e. not limit]
 -h, -?            print this and exit
Default input_file_name value is 20_01_in.txt, default output_file_name value is 20_01_out.txt.

Здесь первая строчка - расположение бинарника программы (первое строковое поле аргументов функции main);
                       precision определяет, числа меньше какого считать нулем;
                       epsilon - точность;
                       max_iter - ограничение на число итераций алгоритма (если оно нулевое или отрицательное - ограничений нет).

Пример вызова программы: ./evc input.txt output.txt -e -t -eps=1e-6 -max_iter=10000

Формат входного файла:

   n
   a_1_1 a_1_2 ... a_1_n
   a_2_1 a_2_2 ... a_2_n
   .....................
   a_n_1 a_n_2 ... a_n_n


Здесь n - размерность матрицы, a_i_j - элементы матрицы.

Формат чисел: n - "%d", a_i_j - "%lf".

Формат выходного файла. Если вектор собственных значений найден

   n
   e_1
   e_2
   ...
   e_n

Здесь n - размерность матрицы, e_i - собственные значения, отсортированные в порядке возрастания.
Если метод не применим к входной матрице, выходной файл должен содержать одну единственную цифру 0.

Формат чисел: n - "%d", e_i - "%1.9lf".

Коды ошибок:

  404 (ERROR_OPEN_FILE_IN) 	- ошибка открытия файла для считывания данных. Возможно не правильно указано имя файла.
  406 (ERROR_OPEN_FILE_OUT) 	- ошибка открытия файла для записи ответа. Возможно не правильно указано имя файла.

  68 (ERROR_DIMENSION) 		- ошибка значения(первая строка входного файла для считывания) числа размерности матрицы в файле (размерность должна быть > 1).

  66 (ERROR_DIMENSION_MATRIX_A) - ошибка размерности матрицы A. Возникает, если в матрице А не хватает элементов(при считывании с файла).
				  Матрица A размерности n*n (где n - значение указываемое в первом поле входного файла).

  400 (ERROR_INPUT) 		- ошибка ввода аргументов. Возможные причины: если имя указанных файлов (входного, выходного) не содержит- ".txt", если введеные опции не верно указаны.

  200 (PRINT_INFO) 		- код запроса списка опций.
  500 (ERROR_EMPTY) 		- ошибка - файл пустой.
    0 (SUCCESS) 		- код успешно завершенной программы.

Алгоритм решения задачи:

  1. Приведение матрицы к почти трегольному виду унитарным подобием методом отражений:

	  1.1. Находим s_k, как сумму квадратов элементов под 2ой главной диагонали на k-ом столбце
	  1.2. Находим норму a_k = sqrt(|a_k+1_k|^2 + s_k)
	  1.3. Находим вектор x_k = (a_k+1_k - ||a1||, a_k+2_k,...,a_n_k) и его норму ||x_k|| = sqrt(|x_1|^2 + s_k) и вычисляем искомый вектор x_k_j = x_k_j / ||x_k|| j = 1,...,n-k
	  1.4. Заполняем матрицу U_x = I - 2*x_k*(x_k)^T
	  1.5. Перемножаем матрицы U_x*A*U_x
	  Повторяем операции 1.1 - 1.5 (n-2) раз, затем матрица принимает необходимый почти треугольный вид.

  2. Алгоритм построения LR - разложения для почти треугольной матрицы:

	  2.1. Строим матрицы L и R по слудующим формулам:
	   	r_1_k = a_1_k, k=1,...,n
	   	r_i_k = a_i_k - l_i_i-1 * r_i-1_k, k>=i>1, i,k=2,...,n
	   	l_i_i-1 = a_i_i-1 / r_i-1_i-1, i=2,...,n
	  2.2. Перемножаем матрицы R и L
	  2.3. Условие для нахождения самих собственных чисел:
	   	Берем диагональные элементы матриц на k и k+1 итерации и смотрим разницу этих элементов. Если разница < epsilon для каждого элемента, то берем значения диагольной матрицы k+1 шага. 
		Иначе повторяем операции пункта 2 до тех пор, пока не получим необходимую точность.

Функции в файле main_20_01.с:

  size_t sim_memsize_20_01(int n) - определение размера массива дополнительной памяти для модуля sim - модуля упрощения.
				    Входной аргумент - целое число.
				    Возвращаемое значение - int - n * sizeof(double).

  size_t evc_memsize_20_01(int n) - определение размера массива дополнительной памяти для модуля evc - вычислительный модуль.
				    Входной аргумент - целое число.
				    Возвращаемое значение - int - n * sizeof(double).

  int check_str(char * first, char * second, int lim) - сравнение строк с учетом лимината для считывания символов.
					       Aргументы: 2 строки, лимит(int).
					       Возвращаемое значение в случае успеха 0, неудача 1.

  int check_name_txt(char * first) - функция для проверки содержания в названии файлов (ввода/ввывода) ".txt".
				     Aргумент: строка.
				     Возвращаемое значение в случае успеха 0, неудача 1(если в переданной строке не присутсвует ".txt").

  void print_help() - печать образца синтаксиса входных параметров.

  int errors(int code) - печать информации по соответвующему коду ошибки.
			 Аргумент: код ошибки (тип int).
			 Если глобальная переменная var_for_errors == 1 (в параметрах командной строки было передано значение "-e"), то при фильтрации code, 
				на экран пользователя будет выводиться соответсвующее коду ошибки передупреждение.
			 Возвращаемое значение код ошибки (входной аргумент).

  void print_matrix(int n, double *  A, double * B) - печать матрицы A.
						      Аргументы: размерность матрицы (для A, будет n*n), массив матрицы A.

  int main(int argc, char *argv[]) - Аргумент: argc типа integer содержит в себе количество аргументов командной строки.
					       argv типа char - указатель на массив строк.
					       Каждый элемент массива указывает на аргументы командной строки. Один параметр отделяется от другого пробелами.
				     Первым этапом проверяются входные аргументы, если они есть.
				     Выделение памяти под массив значений матрицы A, E, tmp_sim, tmp_evc.
				     Массивы tmp_sim и tmp_evc заполням нулями. Затем считывание данных из входного файла.
				     Печать матриц A, ответа, если глобальный флаг var_for_debug == 1(в параметрах командной строки было передано значение "-d") или было введено с консоли "-p" (print matrix).
				     Запуск модуля упрощения и вычислительного модуля, подсчет времени работы.
				     Запись в выходной файл результата работы вычислительного модуля.
				     Возвращаемое значение в случае успеха 0 (SUCCESS).


Функции в файле sim_20_01.с:

  void print_m(int n, double * A) - печать матриц A.
				    Агрументы: размерность матрицы (для A будет n*n), матрица A.

 void print_m_tmp(int n, double * tmp) - печать дополнительной матрицы, которая используется для перменожения 2х матриц, n*n  размерности.
 					 Аргументы: размерность матрицы, массив tmp. 

  int sim_20_01(int n, double * A, double * tmp, double precision) - основная функция модуля упрощения матрицы, сводящая входную матрицу A к почти треугольному виду унитарным подобием методом отражений.
  								     Аргументы: размерность n, матрица A (массив с матрицей системы в формате a_1_1,..., a_1_n, a_2_1,..., a_2_n,..., a_n_n), 
										массив дополнительной памяти tmp (массив размером 2*n*n+n - под 2 доплнитильные матрицы 
										(для построения матрицы U_x и вспомогательная для перемножения матриц) и один вектор размером n элементов), 
										precision определяет, числа меньше какого считать нулем.
  								     Возвращаемое значение 0: работа завершена успешно, матрица упрощена.
Функции в файле evc_20_01.c:

	void print_m(int n, double * A) - печать матриц A.
					  Агрументы: размерность матрицы (для A, будет n*n), матрица A.

	void bubble_sort(int n, double * vector) - сортировка элементов по возрастанию.
						   Аргументы: размер вектора, вектор элементов, который надо упорядочить по возрастанию.

	int evc_20_01(int n, int max_iterations, double epsilon, double * A, double * E, double * tmp, double precision) -
			основная функция модуля построения собственных значений матрицы.
															   
			Аргументы: размерность n, параметр max_iterations задает ограничение на число итераций алгоритма, если за указанное число итераций алгоритм не сошелся (не достигнута точность epsilon) 
					- следует в массив E положить диагональные элементы матрицы последней итерации. При этом значение max_iterations <= 0 означает, 
					что алгоритм должен выполнятся до получения требуемой точности (без ограничения на число итераций), 
				   epsilon - точность, матрица A (массив с матрицей системы в формате a_1_1,..., a_1_n, a_2_1,..., a_2_n,..., a_n_n), 
			      	   E - массив полученных собственных значений (упорядоченных по возрастанию), массив дополнительной памяти tmp (массив размером n*n+2*n - под LR матрицу и под 2 вектора, 
				       для последующего сравнения диагональных элементов на k и k+1 шаге), 
				   параметр precision определяет "точность локализации нуля", а именно числа, по модулю не превосходящие значения precision, считаются нулевыми.
			Возвращаемые значения: 0 - работа завершена успешно, 1 - метод не сходится за указанное число итераций.

Файл с необходимыми с заголовками task_SS_NN.h:
	
	библиотеки - stdio.h, stdlib.h, math.h, time.h.
	две глобальные переменные - int var_for_debug для отладочной печати,
								int var_for_errors для печати ошибок.
	int sim_20_01(int n, double * A, double * tmp, double precision);
	int evc_20_01(int n, int max_iterations, double epsilon, double* A, double* E, double* tmp, double precision);
	